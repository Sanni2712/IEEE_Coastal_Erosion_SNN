# -*- coding: utf-8 -*-
"""Coastal_IEE_GRSS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ezQ3T6ki62VqCQLQCQu5US_o48yduY_4

# **IEEE GRSS Coastal Erosion Monitoring**
Deep learning based coastal erosion rate prediction model
"""

import pandas as pd
import torch
import torch.nn as nn
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from torch.utils.data import DataLoader, TensorDataset
import joblib
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

"""# **Dataset setup + defining variables**"""

#dataset..
df = pd.read_excel("cedt.xlsx", header=None)

df.columns = ["year", "country", "continent", "population", "area",
              "erosion_rate", "lat", "lon", "elevation"]

print("âœ… Data loaded successfully.")
print(df.head(), "\n")

# setting column
y = df["erosion_rate"]
X = df.drop(columns=["erosion_rate"])

# categorical and numerical columns
categorical_cols = ["country", "continent"]
numerical_cols = [col for col in X.columns if col not in categorical_cols]

# Combine preprocessing steps
preprocessor = ColumnTransformer([
    ("num", StandardScaler(), numerical_cols),
    ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
])

# Fit + transform data
X_processed = preprocessor.fit_transform(X)

# Convert to torch tensors
X_tensor = torch.tensor(X_processed.toarray() if hasattr(X_processed, "toarray") else X_processed, dtype=torch.float32)
y_tensor = torch.tensor(y.values, dtype=torch.float32).view(-1, 1)

# Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_tensor, y_tensor, test_size=0.2, random_state=42)

train_ds = TensorDataset(X_train, y_train)
test_ds = TensorDataset(X_test, y_test)

train_dl = DataLoader(train_ds, batch_size=32, shuffle=True)
test_dl = DataLoader(test_ds, batch_size=32)



"""# **Pytorch Model class**"""

#Define Neural Network
class ErosionModel(nn.Module):
    def __init__(self, input_dim):
        super(ErosionModel, self).__init__()
        self.net = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )

    def forward(self, x):
        return self.net(x)

# Instantiate model
model = ErosionModel(X_train.shape[1])

"""# **Training phase**"""

#Setting up for training
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
epochs = 100


# Training Loop
for epoch in range(epochs):
    model.train()
    total_loss = 0
    for xb, yb in train_dl:
        pred = model(xb)
        loss = criterion(pred, yb)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    if (epoch + 1) % 10 == 0:
        print(f"Epoch [{epoch+1}/{epochs}] - Loss: {total_loss/len(train_dl):.4f}")

#Saving model
torch.save(model.state_dict(), "erosion_model_weights.pth")
joblib.dump(preprocessor, "erosion_preprocessor.pkl")

print("\nðŸ’¾ Model weights saved as 'erosion_model_weights.pth'")
print("ðŸ’¾ Preprocessor saved as 'erosion_preprocessor.pkl'")

"""# **Evaluation Phase**"""

#Evaluation Phase

model.eval()
with torch.no_grad():
    preds = model(X_test)
    test_loss = criterion(preds, y_test)
    print(f"\nâœ… Test MSE: {test_loss.item():.4f}")

model.eval()
with torch.no_grad():
    preds = model(X_test)
    y_true = y_test.numpy()
    y_pred = preds.numpy()

# Calculate metrics
mse = mean_squared_error(y_true, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_true, y_pred)
r2 = r2_score(y_true, y_pred)

print("\nðŸ“Š Evaluation Metrics:")
print(f"MSE  (Mean Squared Error): {mse:.4f}")
print(f"RMSE (Root Mean Squared Error): {rmse:.4f}")
print(f"MAE  (Mean Absolute Error): {mae:.4f}")
print(f"RÂ² Score (Model Accuracy): {r2:.4f}")
